from collections import namedtuple
import random
import sys
import logging
import time

# Change log level to DEBUG
logging.basicConfig(level = logging.INFO)

def anyof(s):
    return next(iter(s)) if s else None

"""
[Liu] Copied from paper, except:
  replaced latex to use ascii <-, |>, <, >, and, or, in, -, '', ', big(
  added _ before subscript

Algorithm 1 Utilities (for replica r).
 1: function Msg(type, node, qc)
 2:   m.type <- type
 3:   m.viewNumber <- curView
 4:   m.node <- node
 5:   m.justify <- qc
 6: return m
 7: function voteMsg(type, node, qc)
 8:   m <- Msg(type, node, qc)
 9:   m.partialSig <- tsign_r (<m.type, m.viewNumber, m.node>)
10: return m
11: procedure createLeaf(parent, cmd)
12:   b.parent <- parent
13:   b.cmd <- cmd
14: return b
15: function QC(V)
16:   qc.type <- m.type : m in V
17:   qc.viewNumber <- m.viewNumber : m in V
18:   qc.node <- m.node : m in V
19:   qc.sig <- tcombine(<qc.type, qc.viewNumber, qc.node>,
      	     		{m.partialSig | m in V })
20: return qc
21: function matchingMsg(m, t, v)
22:   return (m.type = t) and (m.viewNumber = v)
23: function matchingQC(qc, t, v)
24:   return (qc.type = t) and (qc.viewNumber = v)
25: function safeNode(node, qc)
26:   return (node extends from lockedQC.node) or // safety rule
27:  (qc.viewNumber > lockedQC.viewNumber) // liveness rule

Algorithm 2 Basic HotStuff protocol (for replica r).
 1: for curView <- 1, 2, 3, . . . do
    |> prepare phase
 2:   as a leader // r = leader(curView)
      // we assume special new-view messages from view 0
 3:     wait for (n - f ) new-view messages:
             M <- {m | matchingMsg(m, new-view, curView-1)}
 4:     highQC <-
        (
        argmax
        m in M
        {m.justify.viewNumber}
        )
        .justify
 5:     curProposal <- createLeaf(highQC.node,
                                  client's command)
 6:     broadcast Msg(prepare, curProposal, highQC)
 7: as a replica
 8:   wait for message m from leader(curView)
           m : matchingMsg(m, prepare, curView)
 9:   if m.node extends from m.justify.node and
                safeNode(m.node, m.justify) then
10:    send voteMsg(prepare, m.node, bot) to leader(curView)
    |> pre-commit phase
11:   as a leader
12:     wait for (n - f ) votes:
	     V <- {v | matchingMsg(v, prepare, curView)}
13:     prepareQC <- QC(V)
14:     broadcast Msg(pre-commit, bot, prepareQC)
15:   as a replica
16:     wait for message m from leader(curView)
	     m : matchingQC(m.justify, prepare, curView)
17:     prepareQC <- m.justify
18:     send to leader(curView)
	     voteMsg(pre-commit, m.justify.node, bot)
    |> commit phase
19:   as a leader
20:     wait for (n - f ) votes:
             V <- {v | matchingMsg(v, pre-commit, curView)}
21:     precommitQC <- QC(V)
22:     broadcast Msg(commit, bot, precommitQC)
23:   as a replica
24:     wait for message m from leader(curView)
             m : matchingQC(m.justify, pre-commit, curView)
25:     lockedQC <- m.justify
26:     send to leader(curView)
             voteMsg(commit, m.justify.node, bot)
    |> decide phase
27: as a leader
28:   wait for (n - f ) votes:
      	 V <- {v | matchingMsg(v, commit, curView)}
29:   commitQC <- QC(V)
30:   broadcast Msg(decide, bot, commitQC)
31: as a replica
32:   wait for message m from leader(curView)
      	   m : matchingQC(m.justify, commit, curView)
33:   execute new commands through m.justify.node,
      respond to clients
    |> Finally
34:   nextView interrupt: goto this line if nextView(curView) is
      called during "wait for" in any phase
35:   send Msg(new-view, bot, prepareQC) to leader(curView + 1)
"""

""" Algorithm 1 (Utilities) - From paper
---------------------------------------- Object methods ----------------------------------------
function Msg(type, node, qc)
function voteMsg(type, node, qc)
procedure createLeaf(parent, cmd)
function QC(V)
function safeNode(node, qc)

---------------------------------------- Utility functions -------------------------------------
matchingMsg(m, t, v)
machtingQC(qc, t, v)
"""

"""
Modify from the paper:
    1. namedtuples for Msg and QC
    2. Use list to represent blockchain
        2.1 modified createLeaf function for list
        2.2 safeNode function for list
        2.3 check node.extend (use list_extends instead)
"""

# Type definition: Msg and QC
Justify = namedtuple('Justify', ['type', 'viewNumber', 'node', 'sig'])                    # Algorithm 1: Line 15 - 20
Message = namedtuple('Message', ['type', 'viewNumber', 'node', 'justify', 'partialSig'], defaults = (None, ))      # Algorithm 1: Line 1 - 6

# MODIFIED from the paper
def list_extends(l1, l2):
    '''Check if l1 extends l2, works for frozen list as well'''
    if l2 == None:
        return True
    elif l1 == None:
        return False
    return list(l1)[:len(l2)] == list(l2)


# Utility functions (from paper)
# Not explicitly defined in the paper
def tcombine(m, s: set):
    '''Dummy signature combine function.
    Args:
        m: message
        s: set of partial signatures
    '''
    return set(s)
    

class Replica(process):
    def setup(replicas: set, client: set, f: int, nextViewTimeout: float):        
        # 4.2 - Bookkeeping variables
        self.curView = 0
        self.prepareQC = None
        self.lockedQC = None
        self.blocks = list()  # Not explicitly defined in the paper
        self.replicas = frozenset(replicas)  # Set of replicas

        # Not explicitly defined in the paper
        self.n = len(replicas)   # Number of replicas
        self.replica_index = {i: add for i, add in enumerate(sorted(list(replicas)))}    # Index of replicas -- used in leader rotation
        self.pid = sorted(list(replicas)).index(self)
        self.cmd = None
    
    def run():
        broadcast(Message('NEW-VIEW', 0, None, self.prepareQC))          # Special new-view messages from view 0

        while True:         # For curView <- 1, 2, 3, . . . do
            curView += 1
            if await(leader_role() if is_leader() else replica_role()):
                pass
            elif timeout(nextViewTimeout):
                pass

            nextView()

            time.sleep(2)

    def leader_role():
        output(f'[{pid}] Enter leader role, view: {int(curView)}')

        # PREPARE PHASE
        await(len(setof((m, p), received(m, from_ = p), matchingMsg(m, 'NEW-VIEW', curView - 1))) >= n - f)
        
        M = setof(m, received(m), matchingMsg(m, 'NEW-VIEW', curView - 1))  # [DEBUG]
        output(f'[{pid}] Messages collected: {M}')                                          # [DEBUG]

        # highQC = anyof(
        #     setof(m in {m for m, _ in M}, m.justify.viewNumber == max(setof(m1.justify.viewNumber, (m1, _) in M, m1.justify != None)))
        # ) if not each((m, p) in M, has = m.justify == None) else None

        highQC = to_justify(anyof(
            setof(m.justify, m in M, m.justify.viewNumber == max(setof(m1.justify.viewNumber, m1 in M, m1.justify != None)))         
        )) if some(m in M, has = m.justify != None) else None

        output(f'[{pid}] HighQC: {highQC}')  # [DEBUG]

        curProposal = createLeaf(highQC.node if highQC is not None else list(), random.randint(0, 100))  # Line 5
        
        output(f'[{pid}] Current proposal: {curProposal}')  # [DEBUG]

        broadcast(Msg('PREPARE', curProposal, highQC))

        # PRE-COMMIT PHASE
        await(len(setof((vote, p), received(vote, from_ = p), matchingMsg(vote, 'PREPARE', curView))) >= n - f)
        output(f'Messgae received: {setof((vote, p), received(vote, from_ = p), matchingMsg(vote, "PREPARE", curView))}')  # [DEBUG]
        output(f'[{pid}] Received PREPARE messages.')  # [DEBUG]

        prepareQC = QC(setof(m, received(m), matchingMsg(m, 'PREPARE', curView)))                         # TODO: QC function implementation
        #send((Msg('PRE-COMMIT', None, prepareQC)), to = replicas)
        broadcast(Msg('PRE-COMMIT', None, prepareQC))

        # COMMIT PHASE
        await(len(setof(p, received(vote, from_ = p), matchingMsg(vote, 'PRE-COMMIT', curView))) >= n - f)
        output(f'lp2')
        output(f'Message received: {setof(p, received(vote, from_ = p), matchingMsg(vote, "PRE-COMMIT", curView))}')  # [DEBUG]
        precommitQC = QC(setof(m, received(m), matchingMsg(m, 'PRE-COMMIT', curView)))
        broadcast(Msg('COMMIT', None, precommitQC))

        # DECIDE PHASE
        await(len(setof(p, received(vote, from_ = p), matchingMsg(vote, 'COMMIT', curView))) >= n - f)
        output(f'lp3')
        output(f'Message received: {setof(p, received(vote, from_ = p), matchingMsg(vote, "COMMIT", curView))}')  # [DEBUG]
        commitQC = QC(setof(m, received(m), matchingMsg(m, 'COMMIT', curView)))
        broadcast(Msg('DECIDE', None, commitQC))
        
        return True
    
    def to_justify(qc):
        ''' Transform every frozen obj to normal obj in the qc. This is to mitigate issue with lost messages in distalgo.'''
        return Justify(qc.type, qc.viewNumber, list(qc.node) if qc.node != None else None, set(qc.sig) if qc.sig != None else None)
    
    def replica_role():
        output(f'[{pid}] Enter replica role, view: {int(curView)}')
        leader_p = get_leader(curView)  # Leader of the current view
        
        # PREPARE PHASE
        await(some(received(m, from_ = leader_p), has = matchingMsg(m, 'PREPARE', curView)))     # Line 8
        
        # TODO: FINISH THIS PART [Line 9 - 10]
        (mnode, mjustify) = anyof(setof((m.node, m.justify), received(m, from_ = leader_p), matchingMsg(m, 'PREPARE', curView)))

        output(f'[{pid}] Received message: {mnode}, {mjustify}')  # [DEBUG]

        # What if mjustify is None?
        if list_extends(mnode, mjustify.node if mjustify is not None else None) and safeNode(mnode, mjustify.node if mjustify is not None else None): # Line 9
            send(voteMsg('PREPARE', list(mnode), None), to = leader_p) # Line 10, need to wrap frozenlist with list so it can be unpickeled
            output(f'[{pid}] Sent vote message to leader {leader_p}.')  # [DEBUG]

        # PRE-COMMIT PHASE
        await(some(received(m, from_ = leader_p), has = matchingQC(m.justify, 'PREPARE', curView))) # Line 16
        s = setof(m.justify, received(m, from_ = leader_p), matchingQC(m.justify, 'PREPARE', curView))
        output(f'[{pid}] Received PREPARE message = {s}.')  # [DEBUG]
        prepareQC = to_justify(anyof(setof(m.justify, received(m, from_ = leader_p), matchingQC(m.justify, 'PREPARE', curView))))
        send(voteMsg('PRE-COMMIT', prepareQC.node, None), to = leader_p) # Line 17

        # COMMIT PHASE
        await(some(received(m, from_ = leader_p), has = matchingQC(m.justify, 'PRE-COMMIT', curView))) # Line 24
        lockedQC = to_justify(anyof(setof(m.justify, received(m, from_ = leader_p), matchingQC(m.justify, 'PRE-COMMIT', curView))))
        send(voteMsg('COMMIT', lockedQC.node, None), to = leader_p) # Line 25
        
        # DECIDE PHASE
        # Line 32: wait for message m form leader(curView)?
        await(some(received(m, from_ = leader_p), has = matchingQC(m.justify, 'COMMIT', curView))) # Line 33
        execute(anyof(setof(m.justify, received(m, from_ = leader_p), matchingQC(m.justify, 'COMMIT', curView)))) # Line 34

        output(f'[{pid}] prepareQC = {prepareQC}, lockedQC = {lockedQC}')  # [DEBUG]
        
        return True
    
    # def receive(msg = ('COMMAND', command_n, command)):
    #     output(f'Received command {command} from client.')
    #     self.cmd = command

    def execute(qc):
        output(f'Executing command {qc.node}.')
        # TODO: impl

    def get_leader(viewNumber):
        return replica_index[viewNumber % n]
    
    def is_leader():
        return pid == curView % n

    def broadcast(msg):
        output(f'Broadcast message {msg} to replicas {self.replicas}.')
        send(msg, to = self.replicas)
    
    def nextView():
        # [Paper] goto this line if nextView(curView) is called during “wait for” in any phase
        output(f'Sending NEW-VIEW message: {Msg("NEW-VIEW", None, prepareQC)} to leader {get_leader(curView + 1)}')
        send(Msg('NEW-VIEW', None, prepareQC), to = get_leader(curView + 1))
    
    # MODIFIED from the paper
    def createLeaf(parent, cmd):
        parent = list(parent)
        parent.append(cmd)
        return parent

    def voteMsg(mtype, node, qc):
        m = Msg(mtype, list(node) if node else None, qc)
        m = m._replace(partialSig=tsign((m.type, m.viewNumber, m.node)))
        output(f'Vote message: {m}') # [DEBUG]
        return m
    
    def Msg(mtype, node, qc):
        return Message(mtype, curView, list(node) if node != None else None, qc)
    
    # Not explicitly defined in the paper
    def tsign(m):
        ''' Dummy function, only gives pid. TODO: use a real threshold signature lib '''
        output(f'Signing message {m}')  # [DEBUG]
        return pid
    
    def safeNode(node, qc):     # Line 25 - 27
        return (list_extends(node, None if self.lockedQC == None else self.lockedQC.node) or qc.viewNumber > self.lockedQC.viewNumber)
    
    def QC(V):
        '''Returns the QC given a setof vote messages in V'''
        m = anyof(V)
        if m == None:
            return None
        justify = Justify(m.type, m.viewNumber, list(m.node) if m.node != None else None, tcombine((m.type, m.viewNumber, m.node), {m.partialSig for m in V}))
        output(f'QC: {justify}')  # [DEBUG]
        return justify

    def matchingMsg(m, t, v):
        # output(f'[{pid}] Matching message {m} with type {t} and view number {v}') # [DEBUG]
        if isinstance(m, Message):
            return m.type == t and m.viewNumber == v
        else:
            try:
                _m = Message._make(m)
                output(f'[{pid}] matched: {_m.type == t and _m.viewNumber == v}')
                return _m.type == t and _m.viewNumber == v
            except TypeError:
                return False

    def matchingQC(qc, t, v):
        if isinstance(qc, Justify):
            return qc.type == t and qc.viewNumber == v
        else:
            try:
                _qc = Justify._make(qc)
                return _qc.type == t and _qc.viewNumber == v
            except TypeError:
                return False

# class Client(process):
#     def setup(replicas: set, f: int):
#         self.replicas = replicas
#         self.command_n = 0
    
#     def run():
#         for i in range(10):
#             command = random.randint(0, 100)
#             output(f'Client sends command {command}.')
#             # Client broadcasts command to replicas
#             send(('COMMAND', command_n, command), to = replicas)
#             # Await for f + 1 responses
#             await(len(setof(p, received(('ACK', command_n), from_ = p))) >= f + 1)
#             output(f'Command: {command} committed.')
             
def main():
    nReplicas = int(sys.argv[1]) if len(sys.argv) > 1 else 4
    nFaulty = int(sys.argv[2]) if len(sys.argv) > 2 else 1
    nextViewTimeout = float(sys.argv[4]) if len(sys.argv) > 4 else 10.0
    
    assert nReplicas > 3 * nFaulty, 'nReplicas should be greater than 3 * nFaulty'

    replicas = new(Replica, num = nReplicas)
    # client = new(Client, num = 1)

    setup(replicas, (replicas, None, nFaulty, nextViewTimeout))
    # setup(client, (replicas, nFaulty))

    start(replicas)

    await(False)
    # start(client)